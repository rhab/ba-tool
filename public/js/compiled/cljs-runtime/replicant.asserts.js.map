{"version":3,"sources":["replicant/asserts.cljc"],"mappings":";AA8DA,mCAAA,nCAAMA,8EAAaC;AAAnB,+KACOA,5CACA,iBAAA,jBAACC,tEACD,AAACC,4CAAIC,zGACL,yDAAA,lDAACC;;AAER,qCAAA,rCAAMC,kFAAeC;AAArB,AACE,OAACC,gDAAQ,AAACR,iCAAY,AAACS,eAAKF","names":["replicant.asserts/camel->dash","s","cljs.core/re-seq","cljs.core.map","clojure.string/lower-case","clojure.string.join","replicant.asserts/camel->dash-k","k","cljs.core.keyword","cljs.core/name"],"sourcesContent":["(ns replicant.asserts\n  (:require [replicant.assert :as assert]\n            [replicant.hiccup :as hiccup]\n            [clojure.string :as str])\n  #?(:cljs (:require-macros [replicant.asserts])))\n\n(defmacro assert-no-class-name [headers]\n  `(assert/assert\n    (not (contains? (hiccup/attrs ~headers) :className))\n    \"Use :class, not :className\"\n    \":className is not supported, please use :class instead. It takes a keyword, a string, or a collection of either of those.\"\n    (hiccup/sexp ~headers)))\n\n(defmacro assert-no-space-separated-class [headers]\n  `(assert/assert\n    (let [class# (:class (hiccup/attrs ~headers))]\n      (or (not (string? class#)) (< (.indexOf class# \" \") 0)))\n    \"Avoid space separated :class strings\"\n    (let [class# (:class (hiccup/attrs ~headers))]\n      (str \":class supports collections of keywords and/or strings as classes. These perform better, and are usually more convenient to work with. Solve by converting \"\n           (pr-str class#) \" to \" (pr-str (vec (.split class# \" \")))))\n    (hiccup/sexp ~headers)))\n\n(defmacro assert-no-string-style [headers]\n  `(assert/assert\n    (not (string? (:style (hiccup/attrs ~headers))))\n    \"Avoid string styles\"\n    \":style supports structured maps of CSS property/value pairs. Strings must be parsed, so they're both slower and harder to read and write.\"\n    (hiccup/sexp ~headers)))\n\n(defmacro assert-event-handler-casing [k]\n  `(assert/assert\n    (let [event# (name ~k)]\n      (or (= \"DOMContentLoaded\" event#)\n          (= event# (str/lower-case event#))))\n    (str \"Use \" (keyword (str/lower-case (name ~k))) \", not \" ~k)\n    (str \"Most event names should be in all lower-case. Replicant passes your event names directly to addEventListener, and mis-cased event names will fail silently.\")))\n\n(defmacro assert-style-key-type [k]\n  `(assert/assert\n    (or (string? ~k) (keyword? ~k) (symbol? ~k))\n    (str \"Style key \" ~k \" should be a keyword\")\n    \"Replicant expects your style keys to be strings, or the very least something that supports `name`. Other types will not work as expected.\"))\n\n(defmacro assert-non-empty-id [tag]\n  `(assert/assert\n    (not (re-find #\"#($|\\.)\" ~tag))\n    (str \"Hiccup tag \" ~tag \" contains an empty id\")\n    \"Either complete the id or remove the # character.\"))\n\n(defmacro assert-valid-id [tag]\n  `(assert/assert\n    (not (re-find #\"#[^a-zA-Z_\\.]\" ~tag))\n    (str \"Hiccup tag \" ~tag \" contains an invalid id\")\n    \"IDs must start with a letter.\"))\n\n(defmacro assert-non-empty-class [tag]\n  `(assert/assert\n    (not (re-find #\"\\.$\" ~tag))\n    (str \"Hiccup tag \" ~tag \" contains an empty class\")\n    \"This may cause a DOMException and is considered a coding error. Replicant will not sacrifice performance to work around it.\"))\n\n(defn camel->dash [s]\n  (->> s\n       (re-seq #\"[A-Z][a-z0-9]*|[a-z0-9]+\")\n       (map str/lower-case)\n       (str/join \"-\")))\n\n(defn camel->dash-k [k]\n  (keyword (camel->dash (name k))))\n\n(defmacro assert-style-key-casing [k]\n  `(assert/assert\n    (let [name# (name ~k)]\n      (or (str/starts-with? name# \"--\")\n          (= name# (str/lower-case name#))))\n    (str \"Use \" (camel->dash-k ~k) \", not \" ~k)\n    \"Replicant passes style keys directly to `el.style.setProperty`, which expects CSS-style dash-cased property names.\"))\n\n(defmacro assert-no-event-attribute [k]\n  `(assert/assert\n    (not (str/starts-with? (name ~k) \"on\"))\n    \"Set event listeners in the :on map\"\n    (str \"Event handler attributes are not supported. Instead of \"\n         ~k \" set :on {\" (keyword (camel->dash (.substring (name ~k) 2))) \" ,,,}\")))\n"],"x_google_ignoreList":[0]}